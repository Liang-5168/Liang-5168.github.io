<script>
  document.addEventListener("DOMContentLoaded", () => {
    const $$ = (s, root = document) => Array.from(root.querySelectorAll(s));
    const $ = (s, root = document) => root.querySelector(s);
    const clamp = (n, min, max) => Math.min(max, Math.max(min, n));

    /* =========================
       HERO: typewriter + entrance
       ========================== */
    const hero = $(".hero");
    const titleEl = $("#hero-title");
    const subtitleEl = $("#hero-subtitle");
    const scrollHint = $("#scroll-hint");
    const landingVideo = $("#landing-video");
    const typeTargets = [titleEl, subtitleEl].filter(Boolean);
    const heroEntrances = $$(".hero-entrance");
    let hasRun = false;

    typeTargets.forEach((el) => {
      const text = el.dataset.text || el.textContent.trim();
      el.dataset.text = text;
      el.textContent = "";
    });

    const typeText = (el, speed = 85) =>
      new Promise((resolve) => {
        const text = el.dataset.text || "";
        let index = 0;
        el.classList.add("typing");
        const tick = () => {
          el.textContent += text.charAt(index);
          index += 1;
          if (index < text.length) setTimeout(tick, speed);
          else {
            el.classList.remove("typing");
            el.classList.add("done");
            resolve();
          }
        };
        tick();
      });

    const startSequence = async () => {
      if (hasRun) return;
      hasRun = true;
      heroEntrances.forEach((item) => item.classList.add("is-visible"));
      for (const el of typeTargets) await typeText(el);
      requestAnimationFrame(() => setTimeout(() => scrollHint?.classList.add("visible"), 350));
    };

    if ("IntersectionObserver" in window && hero) {
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              startSequence();
              observer.disconnect();
            }
          });
        },
        { threshold: 0.35 }
      );
      observer.observe(hero);
    } else {
      startSequence();
    }

    /* =========================
       Landing video: keep muted autoplay
       ========================== */
    if (landingVideo) {
      const attemptPlay = () => {
        const p = landingVideo.play();
        if (p && typeof p.then === "function") p.catch(() => {});
      };
      attemptPlay();
    }

    /* =========================
       Reveal on scroll
       ========================== */
    const revealEls = $$(".reveal");
    if ("IntersectionObserver" in window) {
      const revealObs = new IntersectionObserver(
        (entries) => {
          entries.forEach((e) => {
            if (e.isIntersecting) e.target.classList.add("is-visible");
          });
        },
        { threshold: 0.18 }
      );
      revealEls.forEach((el) => revealObs.observe(el));
    } else {
      revealEls.forEach((el) => el.classList.add("is-visible"));
    }

    /* =========================
       Sticky mini nav active state
       ========================== */
    const navLinks = $$(".mini-nav a[data-section]");
    const sections = navLinks.map((a) => document.getElementById(a.dataset.section)).filter(Boolean);
    const setActive = (id) => navLinks.forEach((a) => a.classList.toggle("active", a.dataset.section === id));

    if ("IntersectionObserver" in window && sections.length) {
      const secObs = new IntersectionObserver(
        (entries) => {
          const visible = entries.filter((e) => e.isIntersecting).sort((a, b) => b.intersectionRatio - a.intersectionRatio)[0];
          if (visible) setActive(visible.target.id);
        },
        { threshold: [0.22, 0.35, 0.5, 0.65] }
      );
      sections.forEach((s) => secObs.observe(s));
    }

    /* =========================
       Progress bar (page progress)
       ========================== */
    const progressFill = $("#progress-fill");
    const updateProgress = () => {
      if (!progressFill) return;
      const doc = document.documentElement;
      const scrollTop = doc.scrollTop || document.body.scrollTop;
      const scrollH = doc.scrollHeight - doc.clientHeight;
      const p = scrollH > 0 ? (scrollTop / scrollH) * 100 : 0;
      progressFill.style.width = `${clamp(p, 0, 100)}%`;
    };
    window.addEventListener("scroll", updateProgress, { passive: true });
    updateProgress();

    /* =========================
       Chapter 01 Sticky Compare
       ========================== */
    const compareMedia = $("#compare-media");
    const compareSteps = $$(".js-sticky-step");
    const setActiveStep = (steps, activeEl) => steps.forEach((s) => s.classList.toggle("is-active", s === activeEl));

    if (compareMedia && compareSteps.length && "IntersectionObserver" in window) {
      const obs = new IntersectionObserver(
        (entries) => {
          const candidates = entries.filter((e) => e.isIntersecting);
          if (!candidates.length) return;
          candidates.sort((a, b) => b.intersectionRatio - a.intersectionRatio);
          const top = candidates[0].target;

          setActiveStep(compareSteps, top);
          const src = top.dataset.media;
          if (src && compareMedia.getAttribute("src") !== src) compareMedia.src = src;
        },
        { threshold: [0.35, 0.5, 0.65, 0.8] }
      );

      compareSteps.forEach((s) => obs.observe(s));
    }

    /* =========================
       Chapter 02 Sticky Narrative: keep loop playing + swap poster hint
       ========================== */
    const loopVideo = $("#redpacket-loop");
    if (loopVideo) {
      const tryPlay = () => {
        const p = loopVideo.play();
        if (p && typeof p.then === "function") p.catch(() => {});
      };
      tryPlay();
    }

    const steps2 = $$(".js-sticky-step-2");
    if (steps2.length && "IntersectionObserver" in window) {
      const obs2 = new IntersectionObserver(
        (entries) => {
          const candidates = entries.filter((e) => e.isIntersecting);
          if (!candidates.length) return;
          candidates.sort((a, b) => b.intersectionRatio - a.intersectionRatio);
          const top = candidates[0].target;

          setActiveStep(steps2, top);

          const media = top.dataset.media;
          const kind = top.dataset.kind;
          if (loopVideo && media) {
            if (kind === "img" || kind === "poster") loopVideo.poster = media;
          }
        },
        { threshold: [0.35, 0.5, 0.65, 0.8] }
      );

      steps2.forEach((s) => obs2.observe(s));
    }

    /* =========================
       Chapter 03: scroll-lit stage
       ========================== */
    const orderStage = $("#order-stage");
    const orderLines = $$(".js-order-line");
    if (orderStage && orderLines.length && "IntersectionObserver" in window) {
      const obs3 = new IntersectionObserver(
        (entries) => {
          const any = entries.some((e) => e.isIntersecting);
          if (any) orderStage.classList.add("is-lit");
        },
        { threshold: 0.55 }
      );

      orderLines.forEach((l) => obs3.observe(l));
    } else if (orderStage) {
      orderStage.classList.add("is-lit");
    }

    /* =========================
       Chapter 04 Horizontal scroll: **使用 requestAnimationFrame 優化流暢度**
       ========================== */
    const hscrollSection = $("#chapter-elements");
    const track = $("#hscroll-track");
    const spacer = $("#hscroll-spacer");
    const head = hscrollSection ? hscrollSection.querySelector(".hscroll-head") : null;
    const panels = track ? track.querySelectorAll(".panel").length : 0;

    const getNavH = () => {
      const style = getComputedStyle(document.documentElement);
      return parseFloat(style.getPropertyValue("--navH")) || 92;
    };

    const setSpacerHeight = () => {
      if (!spacer || panels < 2) return;
      const vh = window.innerHeight;
      // 增加額外高度確保滾動
      spacer.style.height = `${(panels - 1) * vh + Math.round(vh * 0.55)}px`; 
    };

    let lastScrollY = window.scrollY; // 新增：用於儲存滾動位置
    let rafId = null; // 新增：用於儲存 requestAnimationFrame ID

    const calculateHScrollTransform = () => {
        if (!hscrollSection || !track || panels < 2) return 0;
        
        const navH = getNavH();
        const sectionTop = hscrollSection.offsetTop;
        const headH = head ? head.offsetHeight : 0;
        const pin = hscrollSection.querySelector(".hscroll-pin");

        if (!pin || !spacer) return 0;

        const pinStart = sectionTop + headH;
        const pinEnd = pinStart + spacer.offsetHeight;

        // 使用最後一次記錄的滾動位置
        const y = lastScrollY + navH;
        const denom = (pinEnd - pinStart) || 1;
        const t = clamp((y - pinStart) / denom, 0, 1);

        // 計算水平位移 (X)
        const x = t * (panels - 1) * window.innerWidth;
        return x;
    };

    const renderHScroll = () => {
        const newX = calculateHScrollTransform();
        track.style.transform = `translateX(-${newX}px)`;
        
        // 持續呼叫 renderHScroll
        rafId = requestAnimationFrame(renderHScroll);
    };

    const onScrollHScroll = () => {
        // 僅更新滾動位置變數
        lastScrollY = window.scrollY; 
    };

    if (hscrollSection && track && spacer) {
      setSpacerHeight();
      
      // 啟動動畫迴圈
      renderHScroll(); 

      // 監聽滾動事件，僅更新變數
      window.addEventListener("scroll", onScrollHScroll, { passive: true });
      
      // 調整視窗大小時，需重新計算 Spacer 高度並重新渲染一次
      window.addEventListener("resize", () => { 
        setSpacerHeight(); 
        onScrollHScroll(); // 確保 lastScrollY 更新
      });
    }

    /* =========================
       Chapter 05 Scrolled Video: 支持多來源影片替換 (來自第一組邏輯)
       ========================== */
    const svVideo = $("#sv-video");
    const svSource = $("#sv-source");
    const svLines = $$(".js-sv-line");

    const setActiveLine = (activeEl) => svLines.forEach((l) => l.classList.toggle("is-active", l === activeEl));

    // 替換影片來源的邏輯
    const swapVideoSrcIfNeeded = (src, poster) => {
      if (!svVideo || !svSource) return;
      const cur = svSource.getAttribute("src");
      if (src && src !== cur) {
        svVideo.pause();
        svSource.setAttribute("src", src);
        if (poster) svVideo.poster = poster;
        svVideo.load();
      } else if (poster) {
        svVideo.poster = poster;
      }
    };

    if (svVideo && svLines.length && "IntersectionObserver" in window) {
      const obs5 = new IntersectionObserver(
        (entries) => {
          const candidates = entries.filter((e) => e.isIntersecting);
          if (!candidates.length) return;
          candidates.sort((a, b) => b.intersectionRatio - a.intersectionRatio);
          const top = candidates[0].target;

          setActiveLine(top);

          const src = top.dataset.src;
          const poster = top.dataset.poster;
          const t = parseFloat(top.dataset.time || "0");

          // 替換影片來源
          swapVideoSrcIfNeeded(src, poster);

          if (Number.isFinite(t)) {
            const jump = () => {
                // *** [優化] 檢查 readyState 是否準備好播放 (readyState >= 2 表示有數據) ***
                if (svVideo.readyState >= 2) {
                    if (Math.abs(svVideo.currentTime - t) > 0.45) svVideo.currentTime = t;
                    const p = svVideo.play();
                    if (p && typeof p.then === "function") p.catch(() => {});
                } else {
                    // 如果還沒準備好，稍後再試一次
                    setTimeout(jump, 50);
                }
            };
            
            // 如果來源改變，給影片一點時間載入再檢查跳轉
            if (svSource.getAttribute("src") !== src) setTimeout(jump, 80);
            else jump();
          }
        },
        { threshold: [0.55, 0.7, 0.82] }
      );

      svLines.forEach((l) => obs5.observe(l));
    }

    /* =========================
       Modal
       ========================== */
    const backdrop = $("#modal-backdrop");
    const btnClose = $("#modal-close");
    const elTitle = $("#modal-title");
    const elSubtitle = $("#modal-subtitle");
    const elBody = $("#modal-body");
    const elMedia = $("#modal-media");
    const elCaption = $("#modal-caption");
    let lastFocus = null;

    const escapeHtml = (str) =>
      String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");

    const openModalFrom = (host) => {
      if (!backdrop) return;
      lastFocus = document.activeElement;

      const title = host.dataset.title || "";
      const subtitle = host.dataset.subtitle || "";
      const body = host.dataset.body || "";
      const mediaType = host.dataset.mediaType || "";
      const mediaSrc = host.dataset.mediaSrc || "";
      const mediaPoster = host.dataset.mediaPoster || "";
      const mediaCaption = host.dataset.mediaCaption || "";

      if (elTitle) elTitle.textContent = title;
      if (elSubtitle) elSubtitle.textContent = subtitle;
      if (elBody) elBody.innerHTML = `<p>${escapeHtml(body).replace(/\n/g, "<br>")}</p>`;

      if (elMedia) elMedia.innerHTML = "";
      if (elCaption) elCaption.textContent = mediaCaption;

      if (elMedia && mediaType === "video" && mediaSrc) {
        const v = document.createElement("video");
        v.controls = true;
        v.playsInline = true;
        v.preload = "metadata";
        if (mediaPoster) v.poster = mediaPoster;
        const s = document.createElement("source");
        s.src = mediaSrc;
        s.type = "video/mp4";
        v.appendChild(s);
        elMedia.appendChild(v);
      } else if (elMedia && mediaType === "img" && mediaSrc) {
        const img = document.createElement("img");
        img.src = mediaSrc;
        img.alt = `${title} 相關圖片`;
        img.loading = "lazy";
        img.decoding = "async";
        elMedia.appendChild(img);
      }

      backdrop.classList.add("open");
      backdrop.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";
      btnClose?.focus();
    };

    const closeModal = () => {
      if (!backdrop) return;
      backdrop.classList.remove("open");
      backdrop.setAttribute("aria-hidden", "true");
      if (elMedia) elMedia.innerHTML = "";
      if (elBody) elBody.innerHTML = "";
      if (elCaption) elCaption.textContent = "";
      document.body.style.overflow = "";
      if (lastFocus) lastFocus.focus();
    };

    $$(".js-open-modal").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        const panel = e.target.closest(".panel");
        if (panel) openModalFrom(panel);
      });
    });

    btnClose?.addEventListener("click", closeModal);
    backdrop?.addEventListener("click", (e) => {
      if (e.target === backdrop) closeModal();
    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && backdrop?.classList.contains("open")) closeModal();
    });

    // 移除第一組多餘的 smooth scroll，因為已在 CSS 中設定
  });
</script>
