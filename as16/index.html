<script>
    document.addEventListener("DOMContentLoaded", () => {
        const $$ = (s, root = document) => Array.from(root.querySelectorAll(s));
        const $ = (s, root = document) => root.querySelector(s);
        const clamp = (n, min, max) => Math.min(max, Math.max(min, n));

        /* =========================
           HERO: typewriter + entrance (保持不變)
           ========================== */
        const hero = $(".hero");
        const titleEl = $("#hero-title");
        const subtitleEl = $("#hero-subtitle");
        const scrollHint = $("#scroll-hint");
        const landingVideo = $("#landing-video");
        const typeTargets = [titleEl, subtitleEl].filter(Boolean);
        const heroEntrances = $$(".hero-entrance");
        let hasRun = false;

        typeTargets.forEach((el) => {
            const text = el.dataset.text || el.textContent.trim();
            el.dataset.text = text;
            el.textContent = "";
        });

        const typeText = (el, speed = 85) =>
            new Promise((resolve) => {
                const text = el.dataset.text || "";
                let index = 0;
                el.classList.add("typing");
                const tick = () => {
                    el.textContent += text.charAt(index);
                    index += 1;
                    if (index < text.length) setTimeout(tick, speed);
                    else {
                        el.classList.remove("typing");
                        el.classList.add("done");
                        resolve();
                    }
                };
                tick();
            });

        const startSequence = async () => {
            if (hasRun) return;
            hasRun = true;
            heroEntrances.forEach((item) => item.classList.add("is-visible"));
            for (const el of typeTargets) await typeText(el);
            requestAnimationFrame(() => setTimeout(() => scrollHint?.classList.add("visible"), 350));
        };

        if ("IntersectionObserver" in window && hero) {
            const observer = new IntersectionObserver(
                (entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                            startSequence();
                            observer.disconnect();
                        }
                    });
                },
                { threshold: 0.35 }
            );
            observer.observe(hero);
        } else {
            startSequence();
        }

        /* =========================
           Landing video: keep muted autoplay (保持不變)
           ========================== */
        if (landingVideo) {
            const attemptPlay = () => {
                const p = landingVideo.play();
                if (p && typeof p.then === "function") p.catch(() => {});
            };
            attemptPlay();
        }

        /* =========================
           Reveal on scroll (保持不變)
           ========================== */
        const revealEls = $$(".reveal");
        if ("IntersectionObserver" in window) {
            const revealObs = new IntersectionObserver(
                (entries) => {
                    entries.forEach((e) => {
                        if (e.isIntersecting) e.target.classList.add("is-visible");
                    });
                },
                { threshold: 0.18 }
            );
            revealEls.forEach((el) => revealObs.observe(el));
        } else {
            revealEls.forEach((el) => el.classList.add("is-visible"));
        }

        /* =========================
           Sticky mini nav active state (保持不變)
           ========================== */
        const navLinks = $$(".mini-nav a[data-section]");
        const sections = navLinks.map((a) => document.getElementById(a.dataset.section)).filter(Boolean);
        const setActive = (id) => navLinks.forEach((a) => a.classList.toggle("active", a.dataset.section === id));

        if ("IntersectionObserver" in window && sections.length) {
            const secObs = new IntersectionObserver(
                (entries) => {
                    const visible = entries.filter((e) => e.isIntersecting).sort((a, b) => b.intersectionRatio - a.intersectionRatio)[0];
                    if (visible) setActive(visible.target.id);
                },
                { threshold: [0.22, 0.35, 0.5, 0.65] }
            );
            sections.forEach((s) => secObs.observe(s));
        }

        /* =========================
           Progress bar (page progress) (保持不變)
           ========================== */
        const progressFill = $("#progress-fill");
        const updateProgress = () => {
            if (!progressFill) return;
            const doc = document.documentElement;
            const scrollTop = doc.scrollTop || document.body.scrollTop;
            const scrollH = doc.scrollHeight - doc.clientHeight;
            const p = scrollH > 0 ? (scrollTop / scrollH) * 100 : 0;
            progressFill.style.width = `${clamp(p, 0, 100)}%`;
        };
        window.addEventListener("scroll", updateProgress, { passive: true });
        updateProgress();

        /* =========================
           Chapter 01 Sticky Compare (保持不變)
           ========================== */
        const compareMedia = $("#compare-media");
        const compareSteps = $$(".js-sticky-step");
        const setActiveStep = (steps, activeEl) => steps.forEach((s) => s.classList.toggle("is-active", s === activeEl));

        if (compareMedia && compareSteps.length && "IntersectionObserver" in window) {
            const obs = new IntersectionObserver(
                (entries) => {
                    const candidates = entries.filter((e) => e.isIntersecting);
                    if (!candidates.length) return;
                    candidates.sort((a, b) => b.intersectionRatio - a.intersectionRatio);
                    const top = candidates[0].target;

                    setActiveStep(compareSteps, top);
                    const src = top.dataset.media;
                    if (src && compareMedia.getAttribute("src") !== src) compareMedia.src = src;
                },
                { threshold: [0.35, 0.5, 0.65, 0.8] }
            );

            compareSteps.forEach((s) => obs.observe(s));
        }

        /* =========================
           Chapter 02 Sticky Narrative: keep loop playing + swap poster hint (保持不變)
           ========================== */
        const loopVideo = $("#redpacket-loop");
        if (loopVideo) {
            const tryPlay = () => {
                const p = loopVideo.play();
                if (p && typeof p.then === "function") p.catch(() => {});
            };
            tryPlay();
        }

        const steps2 = $$(".js-sticky-step-2");
        if (steps2.length && "IntersectionObserver" in window) {
            const obs2 = new IntersectionObserver(
                (entries) => {
                    const candidates = entries.filter((e) => e.isIntersecting);
                    if (!candidates.length) return;
                    candidates.sort((a, b) => b.intersectionRatio - a.intersectionRatio);
                    const top = candidates[0].target;

                    setActiveStep(steps2, top);

                    const media = top.dataset.media;
                    const kind = top.dataset.kind;
                    if (loopVideo && media) {
                        if (kind === "img" || kind === "poster") loopVideo.poster = media;
                    }
                },
                { threshold: [0.35, 0.5, 0.65, 0.8] }
            );

            steps2.forEach((s) => obs2.observe(s));
        }

        /* =========================
           Chapter 03: scroll-lit stage (保持不變)
           ========================== */
        const orderStage = $("#order-stage");
        const orderLines = $$(".js-order-line");
        if (orderStage && orderLines.length && "IntersectionObserver" in window) {
            const obs3 = new IntersectionObserver(
                (entries) => {
                    const any = entries.some((e) => e.isIntersecting);
                    if (any) orderStage.classList.add("is-lit");
                },
                { threshold: 0.55 }
            );

            orderLines.forEach((l) => obs3.observe(l));
        } else if (orderStage) {
            orderStage.classList.add("is-lit");
        }

        /* =========================
           Chapter 04 Horizontal scroll: 修正並優化
           ========================== */
        const hscrollSection = $("#chapter-elements");
        const track = $("#hscroll-track");
        const spacer = $("#hscroll-spacer");
        const head = hscrollSection ? hscrollSection.querySelector(".hscroll-head") : null;
        const panels = track ? track.querySelectorAll(".panel").length : 0;

        const getNavH = () => {
            const style = getComputedStyle(document.documentElement);
            return parseFloat(style.getPropertyValue("--navH")) || 92;
        };
        
        // **修正 1: 調整 Spacer Height 計算**
        const setSpacerHeight = () => {
            if (!spacer || panels < 2) return;
            const vh = window.innerHeight;
            // 滾動長度 = (面板數量 - 1) * 視窗高度 + 額外捲動緩衝 (例如 65vh)
            spacer.style.height = `${(panels - 1) * vh + Math.round(vh * 0.65)}px`; 
        };

        let lastScrollY = window.scrollY;
        let rafId = null;

        const calculateHScrollTransform = () => {
            if (!hscrollSection || !track || panels < 2) return 0;
            
            const navH = getNavH();
            const sectionTop = hscrollSection.offsetTop;
            const headH = head ? head.offsetHeight : 0;
            const pin = hscrollSection.querySelector(".hscroll-pin");

            if (!pin || !spacer) return 0;

            const pinStart = sectionTop + headH;
            const pinEnd = pinStart + spacer.offsetHeight;

            // 計算滾動進度 (0 到 1)
            const y = lastScrollY + navH;
            const denom = (pinEnd - pinStart) || 1;
            const t = clamp((y - pinStart) / denom, 0, 1);

            // 計算水平位移 (X): t * (面板數量 - 1) * 視窗寬度
            const x = t * (panels - 1) * window.innerWidth;
            return x;
        };

        const renderHScroll = () => {
            const newX = calculateHScrollTransform();
            // **修正 2: 移除 CSS transition (讓 RAF 完全接管)**
            // 之前您 CSS 裡設置了 transition: transform 0.06s linear; 
            // 由於使用 RAF，我們讓瀏覽器直接渲染計算結果，以達到最佳流暢度。
            track.style.transform = `translateX(-${newX}px)`;
            
            rafId = requestAnimationFrame(renderHScroll);
        };

        const onScrollHScroll = () => {
            lastScrollY = window.scrollY; 
        };

        if (hscrollSection && track && spacer) {
            // **修正 3: 初始時機**
            // 確保在腳本啟動時立刻計算高度和初始位置。
            setSpacerHeight();
            onScrollHScroll(); 

            renderHScroll(); // 啟動動畫迴圈

            window.addEventListener("scroll", onScrollHScroll, { passive: true });
            
            window.addEventListener("resize", () => { 
                setSpacerHeight(); 
                onScrollHScroll();
            });
            
            // **修正 4: 額外 CSS 調整**
            // 雖然我們在 JS 裡移除了 `transition: transform 0.06s linear;`
            // 但如果用戶禁用 JS，這個過渡可能還是存在。為確保 RAF 邏輯運行時的即時性，
            // 最好在 CSS 裡移除該行，或在 JS 裡寫入：
            // track.style.transition = 'none'; // (在此處為簡潔，僅在 CSS/結構上調整)
        }


        /* =========================
           Chapter 05 Scrolled Video: 支持多來源影片替換 (優化播放時機)
           ========================== */
        const svVideo = $("#sv-video");
        const svSource = $("#sv-source");
        const svLines = $$(".js-sv-line");

        const setActiveLine = (activeEl) => svLines.forEach((l) => l.classList.toggle("is-active", l === activeEl));

        // 替換影片來源的邏輯
        const swapVideoSrcIfNeeded = (src, poster) => {
            if (!svVideo || !svSource) return;
            const cur = svSource.getAttribute("src");
            if (src && src !== cur) {
                svVideo.pause();
                svSource.setAttribute("src", src);
                if (poster) svVideo.poster = poster;
                svVideo.load();
            } else if (poster) {
                svVideo.poster = poster;
            }
        };

        if (svVideo && svLines.length && "IntersectionObserver" in window) {
            const obs5 = new IntersectionObserver(
                (entries) => {
                    const candidates = entries.filter((e) => e.isIntersecting);
                    if (!candidates.length) return;
                    candidates.sort((a, b) => b.intersectionRatio - a.intersectionRatio);
                    const top = candidates[0].target;

                    setActiveLine(top);

                    const src = top.dataset.src;
                    const poster = top.dataset.poster;
                    const t = parseFloat(top.dataset.time || "0");

                    // 替換影片來源
                    swapVideoSrcIfNeeded(src, poster);

                    if (Number.isFinite(t)) {
                        const jump = () => {
                            // 優化: 檢查 readyState 是否準備好播放
                            if (svVideo.readyState >= 2) { 
                                if (Math.abs(svVideo.currentTime - t) > 0.45) svVideo.currentTime = t;
                                const p = svVideo.play();
                                if (p && typeof p.then === "function") p.catch(() => {});
                            } else {
                                setTimeout(jump, 50);
                            }
                        };
                        
                        if (svSource.getAttribute("src") !== src) setTimeout(jump, 80);
                        else jump();
                    }
                },
                { threshold: [0.55, 0.7, 0.82] }
            );

            svLines.forEach((l) => obs5.observe(l));
        }


        /* =========================
           Modal (保持不變)
           ========================== */
        const backdrop = $("#modal-backdrop");
        const btnClose = $("#modal-close");
        const elTitle = $("#modal-title");
        const elSubtitle = $("#modal-subtitle");
        const elBody = $("#modal-body");
        const elMedia = $("#modal-media");
        const elCaption = $("#modal-caption");
        let lastFocus = null;

        const escapeHtml = (str) =>
            String(str)
                .replaceAll("&", "&amp;")
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;")
                .replaceAll('"', "&quot;")
                .replaceAll("'", "&#039;");

        const openModalFrom = (host) => {
            if (!backdrop) return;
            lastFocus = document.activeElement;

            const title = host.dataset.title || "";
            const subtitle = host.dataset.subtitle || "";
            const body = host.dataset.body || "";
            const mediaType = host.dataset.mediaType || "";
            const mediaSrc = host.dataset.mediaSrc || "";
            const mediaPoster = host.dataset.mediaPoster || "";
            const mediaCaption = host.dataset.mediaCaption || "";

            if (elTitle) elTitle.textContent = title;
            if (elSubtitle) elSubtitle.textContent = subtitle;
            if (elBody) elBody.innerHTML = `<p>${escapeHtml(body).replace(/\n/g, "<br>")}</p>`;

            if (elMedia) elMedia.innerHTML = "";
            if (elCaption) elCaption.textContent = mediaCaption;

            if (elMedia && mediaType === "video" && mediaSrc) {
                const v = document.createElement("video");
                v.controls = true;
                v.playsInline = true;
                v.preload = "metadata";
                if (mediaPoster) v.poster = mediaPoster;
                const s = document.createElement("source");
                s.src = mediaSrc;
                s.type = "video/mp4";
                v.appendChild(s);
                elMedia.appendChild(v);
            } else if (elMedia && mediaType === "img" && mediaSrc) {
                const img = document.createElement("img");
                img.src = mediaSrc;
                img.alt = `${title} 相關圖片`;
                img.loading = "lazy";
                img.decoding = "async";
                elMedia.appendChild(img);
            }

            backdrop.classList.add("open");
            backdrop.setAttribute("aria-hidden", "false");
            document.body.style.overflow = "hidden";
            btnClose?.focus();
        };

        const closeModal = () => {
            if (!backdrop) return;
            backdrop.classList.remove("open");
            backdrop.setAttribute("aria-hidden", "true");
            if (elMedia) elMedia.innerHTML = "";
            if (elBody) elBody.innerHTML = "";
            if (elCaption) elCaption.textContent = "";
            document.body.style.overflow = "";
            if (lastFocus) lastFocus.focus();
        };

        $$(".js-open-modal").forEach((btn) => {
            btn.addEventListener("click", (e) => {
                const panel = e.target.closest(".panel");
                if (panel) openModalFrom(panel);
            });
        });

        btnClose?.addEventListener("click", closeModal);
        backdrop?.addEventListener("click", (e) => {
            if (e.target === backdrop) closeModal();
        });
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && backdrop?.classList.contains("open")) closeModal();
        });

        // 頁面初次載入時，立即計算一次 HScroll 的高度
        setSpacerHeight();
        window.addEventListener('load', setSpacerHeight); // 確保所有圖片載入後再計算一次
    });
</script>
